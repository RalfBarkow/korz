{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-13T19:47:22.739669+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-13T19:47:25.878442+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "IOxhDOD/DQC038JIAPV7gQ=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "Right now this repo is almost pure *theory plus a Baseline*; there’s nothing here that could actually break yet. So as falsifier I’ll focus on what *would* break the moment you try to implement what’s in the Lepiter page, relative to Korz and Ensembles.\n\nI’ll go section by section through that Lepiter page.\n\n---\n\n## 0. Repo-level reality check\n\nFrom `korz-repomix-output.md` we have: \n\n* A `BaselineOfKorz` Metacello baseline that just loads the `Korz` package.\n* An empty `Korz` package (no classes or methods).\n* One Lepiter page with a conceptual model (“Turn the ‘democratically shiftable boundaries’ + Korz + Bricken/Laws-of-Form ideas into something runnable”).\n\nSo:\n\n* **There is no Korz interpreter or slot-space implementation here.**\n  Any claims about “you can implement this tomorrow” are false *for this repo as it stands*. You’d need at least:\n\n  * a slot-space model (coordinates, dimensions, guards, lookup),\n  * a concrete syntax or a host-language embedding (e.g. Pharo objects representing Korz slots),\n  * and some tests.\n\nEverything else is design notes.\n\n---\n\n## 1. “Anti-reflex rule: boundary can’t see itself”\n\n> “No self-vision: (b) never appears as a coordinate in its own guard (closest Korz analogue: no slot can constrain the same dimension it’s currently binding during evaluation).”\n\n**Problems:**\n\n1. **This directly clashes with Korz’s activation model.**\n   Korz *deliberately* copies dimension constraints (e.g. `rcvr`) into the activation, so within the body you can access `rcvr` as an implicit argument. \n\n   * Guards *do* constrain the same dimension whose value they then expose in the activation (e.g. `{ rcvr ≤ stackParent }` constrains `rcvr` and then binds `rcvr` for use in the method body).\n   * Your “no slot can constrain the same dimension it’s binding” rule would outlaw the canonical Korz idiom.\n\n2. **It’s underspecified and ambiguous.**\n\n   * Does “currently binding during evaluation” mean any dimension in the guard? any dimension in the incoming context? just a distinguished “boundary” dimension?\n   * If you formalize it naively (“a guard may not contain a constraint on a dimension that has a binding in the incoming context”), then **almost every useful Korz method becomes illegal** (because they all rely on contextual constraints like `{ rcvr ≤ … }` with `rcvr` bound in the context).\n\n3. **You will kill important patterns:**\n\n   * Guard-based invariants like `{ epoch ≤ e }` or `{ location ≤ southernHemi }` in the point example rely on precisely this “self-seeing” in order to be context-sensitive. \n\n**Falsifier verdict:** as written, the anti-reflex rule is incompatible with core Korz semantics. If you want “mark can’t see itself,” you need a *distinct* meta-dimension or a syntactic restriction that doesn’t outlaw ordinary dimension use.\n\n---\n\n## 2. “Multi-POV via `pov` dimension + Ensembles via `combiner`”\n\n> Use dimensions `pov`, `boundary`, `relation`, `topology` and a `combiner` dimension like `{combiner: ensembleAll}` to mean “run all matching slots”.\n\n**Problems:**\n\n1. **Contradiction with the fundamental Korz lookup contract.**\n   Korz is *built* around: *for a given message, there is exactly one most specific matching slot*, else you get “not understood” or “ambiguous” errors. \n\n   * A `combiner` that says “run *every* matching slot” is explicitly an **escape hatch** suggested as future work, not part of the base semantics. The paper calls out “dimensions that alter interpreter behavior” (e.g. “run every slot for this message”) as speculative future extensions.\n   * You’re baking that extension into the *core model* without addressing all the knock-on effects (super / call-next-method, error handling, ordering of combined slots, etc.).\n\n2. **Unclear interaction between `pov` and specificity.**\n\n   * If two slots differ only in `{pov ≤ local}` vs `{pov ≤ meta}`, and the context has `{pov: meta}`, you’re fine: standard Korz specificity chooses the more specific one. But:\n   * What if both guards match equally specifically (e.g. two different interpretations with the same `pov` constraint)? Your `combiner` might want to run both, but Korz’s core logic will say “ambiguous” unless you rewrite lookup.\n\n3. **No story for *compositionality*.**\n\n   * If `{combiner ≤ meet}` vs `{combiner ≤ sum}` both match a message, what happens?\n   * Are combiners themselves mutually exclusive? Must they lie on a single `combiner` dimension with a linear specificity relation? You haven’t defined the *coordinate hierarchy* for `combiner`, but Korz’s dispatch depends on that partial order.\n\n**Falsifier verdict:** The `combiner` dimension is appealing and matches Ungar’s “Ensembles dimension” idea, but as long as your lookup still expects a unique most-specific guard, you can’t just “flip a switch” and run all matching slots. You need to *explicitly* extend the dispatch algorithm (or stratify “combining” into a meta-level) or your model is internally inconsistent.\n\n---\n\n## 3. Bracket toy semantics (`[(){<>}]` and “sees” tables)\n\nYou propose:\n\n* 4 boundary types as coordinates on `boundaryType`.\n* `sees()` guarded by `{boundaryType ≤ square, topology ≤ currentTopology, pov ≤ p}` returning neighbors.\n* Different `pov`s give different “what X sees” tables.\n\n**Problems:**\n\n1. **“Topology” is undefined as a Korz coordinate space.**\n\n   * You treat `topology` as if it were a single coordinate holding the *entire bracket string structure*.\n   * That collapses “whole-world state” into *one coordinate* — but Korz coordinates have only a parent relation, not arbitrary internal structure. To make this work you’d need to encode the bracket-graph somewhere else (e.g. external data), in which case the `topology` dimension is just a pointer into a separate model.\n\n2. **Adjacency is massively underspecified.**\n\n   * “Adjacent across the boundary” vs “neighbors” needs a concrete rule: is this based on textual position? nesting graph? both?\n   * Korz dispatch only knows about coordinates and their “≤” relation; it doesn’t know about graph edges. So `neighbors()` must call out to a topology engine. Then `boundaryType` and `pov` are *decorations* on that engine, not the actual definition.\n\n3. **Anti-reflex rule is untested here.**\n\n   * You claim the anti-reflex rule is encoded as “exclude `b` itself from `sees()`,” but the original yellow flag rule was about *guards*, not results.\n   * There’s no constraint here that forbids a guard like `{boundaryType ≤ square, pov ≤ p, self ≤ b}` or a context that carries an explicit “this boundary” dimension.\n\n**Falsifier verdict:** As a *story* this is fine. As a semantics it is still a hand-wave. The Korz integration is thin: you’re using Korz as a name-space for knobs, but the real work (adjacency, topology) lives elsewhere and is not specified.\n\n---\n\n## 4. Yoneda / “objects as negative space”\n\n> `profile()` returns a sieve of incoming morphisms selected by `{pov, relation}`, and identity is determined by isomorphism of profiles.\n\n**Problems:**\n\n1. **You’re assuming a category that you haven’t defined.**\n\n   * What are the “morphisms”? Slot invocations? Edges in your boundary graph? Topic map links?\n   * Without a precise notion of morphism and composition, “sieve” and “Yoneda” are metaphor, not a design.\n\n2. **No implementation strategy in Korz terms.**\n\n   * `profile()` must compute over *something*. That “something” is either:\n\n     * all slots that mention the coordinate as a parameter, or\n     * all contexts where the coordinate appears in some dimension, or\n     * some external graph.\n   * You haven’t picked one. Each has very different cost and representation.\n\n3. **Identity equivalence is expensive and nonlocal.**\n\n   * If identity is “profiles are isomorphic”, then every equality check is a potentially huge global traversal.\n   * That collides with Korz’s intended *local* dispatch logic (slot lookup only needs to see guards for a given selector) and with performance in any realistic implementation.\n\n**Falsifier verdict:** The Yoneda gesture is inspirational but not implementable as stated. You need to either drastically weaken it (e.g. profiles over a finite, cached relation set) or treat it as an off-line analysis, not as a runtime identity criterion.\n\n---\n\n## 5. Piles and `selection` dimension (`tops`, `all`, `minimalCut`…)\n\n> A pile is a multiset-of-edges with a `selection` dimension that controls projection.\n\n**Problems:**\n\n1. **Again, the graph lives outside Korz.**\n\n   * A “multiset of edges” is not a Korz primitive. Either:\n\n     * you encode edges as slots and coordinates (then Korz *is* your graph), or\n     * you keep a separate graph and `selection` is just a selector into that external structure.\n\n2. **Selection strategies are not ordered.**\n\n   * For Korz dispatch, `selection` coordinates must live in an inheritance hierarchy (e.g. `tops ≤ visible`, `minimalCut ≤ selectionParent`, etc.).\n   * You haven’t defined such an ordering, but any nontrivial use of `selection` will rely on specificity of selection types.\n\n**Falsifier verdict:** Conceptually plausible, but you haven’t done the Korz work of embedding the pile model into a coordinate hierarchy. Right now it’s just a name.\n\n---\n\n## 6. Croquet / Syndicate mapping (`epoch`, `replica`, conversations)\n\n> Add `epoch`, `replica`, `relation ≤ conversation c` to express synchronization and negotiation.\n\n**Problems:**\n\n1. **Temporal dimensions are tricky in Korz.**\n   Korz already has an open issue around “dimensions that alter interpreter behavior” (e.g. for error handling, failure, ambiguity). \n\n   * If you now make `epoch` part of the guard, you risk:\n\n     * slot explosion (per-epoch variants of everything), or\n     * subtle bugs where the “wrong” epoch hits a too-general guard.\n\n2. **Replica and Croquet-style timewarp require structural changes.**\n\n   * Croquet’s replicated objects and rollback/time travel are not just about additional arguments; they alter evaluation semantics (time slicing, replay, conflict resolution).\n   * You treat this as “just more dimensions”, but Korz’s current semantics assume a *single* slot lookup per message; reconciliation across replicas is a separate combinator logic, not a plain dispatch.\n\n**Falsifier verdict:** Treating Croquet/Syndicate as pure dimensions flattens away the key issues: temporal consistency and reconciliation. If you want this to be serious and not just poetic, you need a story for *how* `epoch` and `replica` influence dispatch and state update.\n\n---\n\n## 7. Equilibrium as `combiner` modes (`meet`, `sum`, `fixpoint`, `quorum(k)`…)\n\nThese are sensible *names* for ensemble-combination strategies, and they resonate with Ungar & Adams’ Ensembles/adverbs work. \n\n**Problems:**\n\n1. **You’re mixing two levels:**\n\n   * In Ly/Ensembles, the “adverb” is part of the *message* (“how to apply this to an ensemble”), not a core dimension of the object model. \n   * In Korz you’re proposing `combiner` as a *dimension in the context*, which implicitly reconfigures dispatch. That’s a deeper change than Ly makes.\n\n2. **No algebra is defined.**\n\n   * `meet` and `sum` suggest a lattice; `fixpoint` suggests iteration over a monotone operator; `quorum(k)` needs a counting measure over POVs.\n   * None of that is spelled out, so you can’t tell whether your combination rules are well-defined or even terminating.\n\n3. **`quorum(k)` is not representable as a plain coordinate.**\n\n   * `{combiner ≤ quorum(k)}` pretends `k` is a static coordinate. But `k` is a *parameter*.\n   * You’d need either:\n\n     * a whole family of coordinates `quorum_1, quorum_2, …`, or\n     * a different representation (e.g. combiner slot that takes `k` as an argument).\n   * As written it doesn’t fit the Korz “coordinate is a value, guards constrain with ≤” template.\n\n**Falsifier verdict:** The list of combiners is a *good naming scheme*, but not yet a coherent Korz extension. You need to choose: either combiners are “adverbs” attached to messages (Ly style), or they’re a meta-dimension with explicit semantics.\n\n---\n\n## 8. “Minimal object model you can implement tomorrow”\n\nYou list dimensions (`rcvr`, `pov`, `boundaryType`, `relation`, `selection`, `combiner`, `epoch`, `replica`) and a few core methods (`neighbors`, `project`, `stabilize`, `profile`), then claim:\n\n> “Now your examples fall out by picking contexts, not rewriting objects. You’ve basically got […] equilibrium → ensemble combination.”\n\n**Problems:**\n\n1. **You have no *data model* yet.**\n\n   * Where are edges stored? In which dimensions? As which coordinates?\n   * How do you represent the bracket string as a Korz slot space?\n   * Without this, `neighbors()` and `project()` have nothing to operate on.\n\n2. **You haven’t defined *any* guards.**\n\n   * It’s not enough to say “define `neighbors()` guarded by `{relation ≤ adjacent, boundaryType ≤ …}`”; you must actually specify:\n\n     * which boundary types get which neighbors,\n     * how conflicts between multiple `neighbors()` slots are resolved via specificity.\n\n3. **The “implement tomorrow” claim is false for Korz-in-Pharo.**\n\n   * In this repo there is no Korz runtime. Implementing a *real* slot space with multidimensional dispatch inside Pharo is at least one new package worth of work: parser or DSL, runtime structures, tests.\n   * At best you can implement a *mocked*, non-Korz version of this model tomorrow.\n\n**Falsifier verdict:** As a checklist for what needs to exist, the list is fine. As a statement about ease of implementation, it’s optimistic to the point of being misleading.\n\n---\n\n## 9. “Where to explore next” / test bullets\n\nYour own “next steps” bullets (encode bracket example, try two-observer conflicts, etc.) are, frankly, the falsifier’s best friends:\n\n* Right now they are all **pending experiments**.\n* Until you actually encode even the first one in a concrete Korz-ish runtime, none of the strong claims (“this captures your idea,” “equilibrium emerges via combiners,” “Yoneda-style identity”) are really testable.\n\n---\n\n## Summing up: what’s actually solid vs shaky\n\n**Relatively solid / compatible with Korz & Ensembles:**\n\n* Using extra dimensions like `pov`, `location`, `isColorblind` to express context (this is exactly what Korz is good at). \n* The idea that “subjective objects” are views over a sea of slots — that’s precisely the Korz pitch. \n* The suggestion from Ungar to use a special dimension to support “run every slot” method combinations, echoing the Ensembles/adverbs direction.\n\n**Shaky / currently self-contradictory:**\n\n* The anti-reflex rule as stated (conflicts with Korz’s use of dimension constraints and activations).\n* Treating combiners as just another dimension without rewriting lookup.\n* Treating topology, Yoneda profiles, Croquet timewarp and Syndicate conversations as “just more dimensions” without specifying the underlying structures or semantics.\n\nIf you want, next step I can flip into “architect-scribe” or “pharo-code-emitter” and sketch a *minimal Pharo implementation* of one tiny piece (e.g. just the bracket `sees()` experiment) so we have an actual thing that can fail, not just concepts.\n"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-11-13T19:47:22.279215+01:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-11-13T19:47:22.279215+01:00"
		}
	},
	"pageType" : {
		"__type" : "unnamedPage",
		"defaultTitle" : "Page"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "2fe05a0c-e0ff-0d00-b4de-302400f57b81"
	}
}