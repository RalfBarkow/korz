{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-14T07:49:14.444239+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-14T07:49:19.512988+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "BBb2Ier/DQCSYhrBCi3ECw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "See [[Probe what we have]"
			},
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-14T07:44:07.104422+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-11-14T07:44:10.130329+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "53OkD+r/DQCRp0N5Ci3ECw=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "You’re right—let’s reset and get back to a **known-good, minimal** working state.\n\nBelow is a **single, self-contained do-it** you can paste and run once. It:\n\n1. Probes your image for the Korz API.\n2. Adds only the **missing** methods on `KoSlotSpace`, `KoSlotGuard`, `KoSlot` (no renames, no overrides).\n3. Compiles your `KoSlotSpaceExamples` exactly as written.\n4. Smoke-tests the examples so you immediately see if we’re good.\n\nIf you’ve already loaded a Korz framework, this won’t clobber it; it only fills the gaps.\n\n```smalltalk\n\"=== Reorient: make examples runnable with minimal shims, then compile+smoke-test ===\"\n\n| needs methodExists klass ensureMethod compileOn ensureClass\n  haveKoSlotSpace haveAddDim haveAddCoord haveAddSlot haveMatch\n  haveKoSlotGuard haveGuardCtor haveGuardAccessors\n  haveKoSlot haveSlotCtor haveSlotAccessors haveEval resultSummary |\n\n\"Helper — check if a class responds to a selector\"\nmethodExists := [ :classSymbol :selector |\n\t| cls |\n\tcls := Smalltalk at: classSymbol ifAbsent: [ ^ false ].\n\tcls canUnderstand: selector ].\n\n\"Helper — compile on class or metaclass\"\ncompileOn := [ :classSymbol :isClassSide :source :protocol |\n\t| cls target |\n\tcls := Smalltalk at: classSymbol ifAbsent: [ ^ self error: 'Missing class: ', classSymbol asString ].\n\ttarget := isClassSide ifTrue: [ cls class ] ifFalse: [ cls ].\n\ttarget compile: source classified: protocol ].\n\n\"Helper — ensure a class exists\"\nensureClass := [ :name :super :package |\n\tSmalltalk at: name ifAbsent: [\n\t\tsuper\n\t\t\tsubclass: name\n\t\t\tinstanceVariableNames: ''\n\t\t\tclassVariableNames: ''\n\t\t\tpackage: package ] ].\n\n\"1) Probe what we have\"\nhaveKoSlotSpace := (Smalltalk includesKey: #KoSlotSpace).\nhaveKoSlotGuard := (Smalltalk includesKey: #KoSlotGuard).\nhaveKoSlot := (Smalltalk includesKey: #KoSlot).\n\nhaveAddDim  := haveKoSlotSpace and: [ (Smalltalk at: #KoSlotSpace) canUnderstand: #addDimensionNamed: ].\nhaveAddCoord:= haveKoSlotSpace and: [ (Smalltalk at: #KoSlotSpace) canUnderstand: #addCoordinateNamed:onDimension:parent: ].\nhaveAddSlot := haveKoSlotSpace and: [ (Smalltalk at: #KoSlotSpace) canUnderstand: #addSlot: ].\nhaveMatch   := haveKoSlotSpace and: [ (Smalltalk at: #KoSlotSpace) canUnderstand: #matchingSlotsForContext:selector:arguments: ].\n\nhaveGuardCtor := haveKoSlotGuard and: [ (Smalltalk at: #KoSlotGuard) class canUnderstand: #selector:dimensionConstraints:parameterConstraints: ].\nhaveGuardAccessors := haveKoSlotGuard\n\tand: [ (Smalltalk at: #KoSlotGuard) canUnderstand: #selector\n\tand: [ (Smalltalk at: #KoSlotGuard) canUnderstand: #dimensionConstraints\n\tand: [ (Smalltalk at: #KoSlotGuard) canUnderstand: #parameterConstraints ] ] ].\n\nhaveSlotCtor := haveKoSlot and: [ (Smalltalk at: #KoSlot) class canUnderstand: #guard:contents: ].\nhaveSlotAccessors := haveKoSlot\n\tand: [ (Smalltalk at: #KoSlot) canUnderstand: #guard\n\tand: [ (Smalltalk at: #KoSlot) canUnderstand: #contents ] ].\nhaveEval := haveKoSlot and: [ (Smalltalk at: #KoSlot) canUnderstand: #evaluateInContext:withArguments: ].\n\n\"2) Create classes if absent\"\nhaveKoSlotSpace ifFalse: [ ensureClass value: #KoSlotSpace value: Object value: 'Korz-Projection-Compat' ].\nhaveKoSlotGuard ifFalse: [ ensureClass value: #KoSlotGuard value: Object value: 'Korz-Projection-Compat' ].\nhaveKoSlot ifFalse: [ ensureClass value: #KoSlot value: Object value: 'Korz-Projection-Compat' ].\n\n\"3) Add only the missing KoSlotSpace API\"\n((Smalltalk at: #KoSlotSpace) canUnderstand: #kozState) ifFalse: [\n\tcompileOn value: #KoSlotSpace value: false value:\n'kozState\n\t^ (Smalltalk at: #KoSlotSpaceState ifAbsentPut: [ WeakKeyDictionary new ])\n\t\tat: self ifAbsentPut: [\n\t\t\tDictionary new\n\t\t\t\tat: #dimensions put: OrderedCollection new;\n\t\t\t\tat: #coordinates put: Dictionary new;  \"dim -> (name -> coord)\"\n\t\t\t\tat: #slots put: OrderedCollection new;\n\t\t\t\tyourself ]'\n\tvalue: 'Korz-Projection-Compat' ].\n\nhaveAddDim ifFalse: [\n\tcompileOn value: #KoSlotSpace value: false value:\n'addDimensionNamed: aSymbol\n\t| st dims |\n\tst := self kozState.\n\tdims := st at: #dimensions.\n\t(dims includes: aSymbol) ifFalse: [ dims add: aSymbol ].\n\t^ aSymbol'\n\tvalue: 'Korz-Projection-Compat' ].\n\nhaveAddCoord ifFalse: [\n\tcompileOn value: #KoSlotSpace value: false value:\n'addCoordinateNamed: aSymbol onDimension: aDim parent: aParent\n\t| st byDim coord |\n\tst := self kozState.\n\tbyDim := (st at: #coordinates) at: aDim ifAbsentPut: [ Dictionary new ].\n\tcoord := byDim at: aSymbol ifAbsentPut: [\n\t\tDictionary newFrom: {\n\t\t\t#name -> aSymbol.\n\t\t\t#dimension -> aDim.\n\t\t\t#parent -> aParent } ].\n\t^ coord'\n\tvalue: 'Korz-Projection-Compat' ].\n\nhaveAddSlot ifFalse: [\n\tcompileOn value: #KoSlotSpace value: false value:\n'addSlot: aSlot\n\t(self kozState at: #slots) add: aSlot.\n\t^ aSlot'\n\tvalue: 'Korz-Projection-Compat' ].\n\nhaveMatch ifFalse: [\n\tcompileOn value: #KoSlotSpace value: false value:\n'matchingSlotsForContext: aContext selector: aSelector arguments: ignored\n\t| slots |\n\tslots := self kozState at: #slots.\n\t^ (OrderedCollection new)\n\t\taddAll: (slots select: [ :slot |\n\t\t\t| g ok |\n\t\t\tg := (slot respondsTo: #guard) ifTrue: [ slot guard ] ifFalse: [ nil ].\n\t\t\tg isNil ifTrue: [ ^ OrderedCollection new ].\n\t\t\t((g respondsTo: #selector) and: [ g selector = aSelector ]) and: [\n\t\t\t\tok := true.\n\t\t\t\t(g respondsTo: #dimensionConstraints) ifTrue: [\n\t\t\t\t\tg dimensionConstraints keysAndValuesDo: [ :dim :coord |\n\t\t\t\t\t\t| ctxVal |\n\t\t\t\t\t\tctxVal := aContext at: dim ifAbsent: [ ok := false. ^ false ].\n\t\t\t\t\t\t(ctxVal == coord) ifFalse: [ ok := false ] ] ].\n\t\t\t\tok ] ]);\n\t\tyourself'\n\tvalue: 'Korz-Projection-Compat' ].\n\n\"4) Add only the missing KoSlotGuard API\"\nhaveGuardCtor ifFalse: [\n\tcompileOn value: #KoSlotGuard value: true value:\n'selector: aSel dimensionConstraints: aDict parameterConstraints: aParamDict\n\t^ self new\n\t\tselector: aSel;\n\t\tdimensionConstraints: (aDict ifNil: [ Dictionary new ]);\n\t\tparameterConstraints: (aParamDict ifNil: [ Dictionary new ]);\n\t\tyourself'\n\tvalue: 'instance creation' ].\n\n((Smalltalk at: #KoSlotGuard) canUnderstand: #selector) ifFalse: [\n\tcompileOn value: #KoSlotGuard value: false value: 'selector ^ selector' value: 'accessing'.\n\tcompileOn value: #KoSlotGuard value: false value: 'selector: aSel selector := aSel' value: 'accessing' ].\n\n((Smalltalk at: #KoSlotGuard) canUnderstand: #dimensionConstraints) ifFalse: [\n\tcompileOn value: #KoSlotGuard value: false value: 'dimensionConstraints ^ dimensionConstraints' value: 'accessing'.\n\tcompileOn value: #KoSlotGuard value: false value: 'dimensionConstraints: aDict dimensionConstraints := aDict' value: 'accessing' ].\n\n((Smalltalk at: #KoSlotGuard) canUnderstand: #parameterConstraints) ifFalse: [\n\tcompileOn value: #KoSlotGuard value: false value: 'parameterConstraints ^ parameterConstraints' value: 'accessing'.\n\tcompileOn value: #KoSlotGuard value: false value: 'parameterConstraints: aDict parameterConstraints := aDict' value: 'accessing' ].\n\n\"5) Add only the missing KoSlot API\"\nhaveSlotCtor ifFalse: [\n\tcompileOn value: #KoSlot value: true value:\n'guard: aGuard contents: aBlock\n\t^ self new guard: aGuard; contents: aBlock; yourself'\n\tvalue: 'instance creation' ].\n\n((Smalltalk at: #KoSlot) canUnderstand: #guard) ifFalse: [\n\tcompileOn value: #KoSlot value: false value: 'guard ^ guard' value: 'accessing'.\n\tcompileOn value: #KoSlot value: false value: 'guard: aGuard guard := aGuard' value: 'accessing' ].\n\n((Smalltalk at: #KoSlot) canUnderstand: #contents) ifFalse: [\n\tcompileOn value: #KoSlot value: false value: 'contents ^ contents' value: 'accessing'.\n\tcompileOn value: #KoSlot value: false value: 'contents: aBlock contents := aBlock' value: 'accessing' ].\n\nhaveEval ifFalse: [\n\tcompileOn value: #KoSlot value: false value:\n'evaluateInContext: aContext withArguments: argArray\n\t^ contents ifNil: [ nil ] ifNotNil: [ contents value: aContext value: argArray ]'\n\tvalue: 'evaluating' ].\n\n\"6) Compile your KoSlotSpaceExamples (class + methods)\"\nensureClass value: #KoSlotSpaceExamples value: Object value: 'Korz-Projection-Examples'.\n\n#(\n'exampleSlotMatching\n\t<gtExample>\n\t| scenario slotSpace dimensions coordinates contexts results |\n\tscenario := self screenScenario.\n\tslotSpace := scenario at: #slotSpace.\n\tdimensions := scenario at: #dimensions.\n\tcoordinates := scenario at: #coordinates.\n\tcontexts := self screenContextsUsingDimensions: dimensions coordinates: coordinates.\n\tresults := Dictionary new.\n\tcontexts keysAndValuesDo: [ :label :context |\n\t\tresults at: label put: (self resultsForContext: context slotSpace: slotSpace selector: #drawPixel) ].\n\t^ results' 'examples'\n\n'exampleBracketSees\n\t<gtExample>\n\t| scenario dims coords slotSpace boundaryDimension povDimension boundaryCoords povs result |\n\tscenario := self bracketSeesScenario.\n\tdims := scenario at: #dimensions.\n\tcoords := scenario at: #coordinates.\n\tslotSpace := scenario at: #slotSpace.\n\tboundaryDimension := dims at: #boundaryType.\n\tpovDimension := dims at: #pov.\n\tboundaryCoords := self bracketBoundaryCoordinatesFrom: coords.\n\tpovs := Dictionary newFrom: {\n\t\t#adjacent -> (coords at: #povAdjacent).\n\t\t#symmetric -> (coords at: #povSymmetric) }.\n\tresult := Dictionary new.\n\tpovs keysAndValuesDo: [ :povLabel :povCoord |\n\t\t| perBoundary |\n\t\tperBoundary := Dictionary new.\n\t\tboundaryCoords keysAndValuesDo: [ :boundaryLabel :boundaryCoord |\n\t\t\t| context |\n\t\t\tcontext := Dictionary newFrom: {\n\t\t\t\tboundaryDimension -> boundaryCoord.\n\t\t\t\tpovDimension -> povCoord }.\n\t\t\tperBoundary at: boundaryLabel put:\n\t\t\t\t(self resultsForContext: context slotSpace: slotSpace selector: #sees) ].\n\t\tresult at: povLabel put: perBoundary ].\n\t^ result' 'examples'\n\n'exampleYonedaProfiles\n\t<gtExample>\n\t| scenario dims coords slotSpace povDimension objectDimension povs objects result |\n\tscenario := self yonedaScenario.\n\tdims := scenario at: #dimensions.\n\tcoords := scenario at: #coordinates.\n\tslotSpace := scenario at: #slotSpace.\n\tpovDimension := dims at: #pov.\n\tobjectDimension := dims at: #object.\n\tpovs := Dictionary newFrom: {\n\t\t#local -> (coords at: #povLocal).\n\t\t#meta -> (coords at: #povMeta) }.\n\tobjects := Dictionary newFrom: {\n\t\t#nodeA -> (coords at: #nodeA).\n\t\t#nodeB -> (coords at: #nodeB).\n\t\t#nodeC -> (coords at: #nodeC) }.\n\tresult := Dictionary new.\n\tpovs keysAndValuesDo: [ :povLabel :povCoord |\n\t\t| perObject |\n\t\tperObject := Dictionary new.\n\t\tobjects keysAndValuesDo: [ :objectLabel :objectCoord |\n\t\t\t| context profile |\n\t\t\tcontext := Dictionary newFrom: {\n\t\t\t\tpovDimension -> povCoord.\n\t\t\t\tobjectDimension -> objectCoord }.\n\t\t\tprofile := self firstResultForContext: context slotSpace: slotSpace selector: #profile.\n\t\t\tperObject at: objectLabel put: profile ].\n\t\tresult at: povLabel put: perObject ].\n\t^ result' 'examples'\n\n'examplePileSelection\n\t<gtExample>\n\t| scenario dims coords slotSpace selectionDimension |\n\tscenario := self pileScenario.\n\tdims := scenario at: #dimensions.\n\tcoords := scenario at: #coordinates.\n\tslotSpace := scenario at: #slotSpace.\n\tselectionDimension := dims at: #selection.\n\t^ Dictionary newFrom: {\n\t\t#tops -> (self resultsForContext: (Dictionary newFrom: {\n\t\t\t\tselectionDimension -> (coords at: #tops) })\n\t\t\tslotSpace: slotSpace selector: #project).\n\t\t#all -> (self resultsForContext: (Dictionary newFrom: {\n\t\t\t\tselectionDimension -> (coords at: #all) })\n\t\t\tslotSpace: slotSpace selector: #project) }' 'examples'\n\n'exampleCombinerPolicies\n\t<gtExample>\n\t| scenario dims coords slotSpace combinerDimension |\n\tscenario := self combinerScenario.\n\tdims := scenario at: #dimensions.\n\tcoords := scenario at: #coordinates.\n\tslotSpace := scenario at: #slotSpace.\n\tcombinerDimension := dims at: #combiner.\n\t^ Dictionary newFrom: {\n\t\t#meet -> (self firstResultForContext: (Dictionary newFrom: {\n\t\t\t\tcombinerDimension -> (coords at: #meet) })\n\t\t\tslotSpace: slotSpace selector: #stabilize).\n\t\t#quorum -> (self firstResultForContext: (Dictionary newFrom: {\n\t\t\t\tcombinerDimension -> (coords at: #quorum) })\n\t\t\tslotSpace: slotSpace selector: #stabilize) }' 'examples'\n\n'firstResultForContext: context slotSpace: slotSpace selector: selector\n\t^ (self resultsForContext: context slotSpace: slotSpace selector: selector) first' 'private - building'\n\n'resultsForContext: context slotSpace: slotSpace selector: selector\n\t^ (slotSpace matchingSlotsForContext: context selector: selector arguments: #())\n\t\tcollect: [ :slot | slot evaluateInContext: context withArguments: #() ]' 'private - building'\n\n'screenContextsUsingDimensions: dimensions coordinates: coordinates\n\t| rcvr location vision screen |\n\trcvr := dimensions at: #rcvr.\n\tlocation := dimensions at: #location.\n\tvision := dimensions at: #isColorblind.\n\tscreen := coordinates at: #screen.\n\t^ Dictionary newFrom: {\n\t\t#australia -> (Dictionary newFrom: { rcvr -> screen. location -> (coordinates at: #australia). vision -> (coordinates at: #false) }).\n\t\t#colorblindAustralia -> (Dictionary newFrom: { rcvr -> screen. location -> (coordinates at: #australia). vision -> (coordinates at: #true) }).\n\t\t#antarctica -> (Dictionary newFrom: { rcvr -> screen. location -> (coordinates at: #antarctica). vision -> (coordinates at: #false) }).\n\t\t#northern -> (Dictionary newFrom: { rcvr -> screen. location -> (coordinates at: #northernHemi). vision -> (coordinates at: #false) }) }' 'private - building'\n\n'screenScenario\n\t| slotSpace dims coords world southern northern |\n\tslotSpace := KoSlotSpace new.\n\tdims := Dictionary new.\n\tdims at: #rcvr put: (slotSpace addDimensionNamed: #rcvr).\n\tdims at: #location put: (slotSpace addDimensionNamed: #location).\n\tdims at: #isColorblind put: (slotSpace addDimensionNamed: #isColorblind).\n\tworld := slotSpace addCoordinateNamed: #world onDimension: (dims at: #location) parent: nil.\n\tsouthern := slotSpace addCoordinateNamed: #southernHemi onDimension: (dims at: #location) parent: world.\n\tnorthern := slotSpace addCoordinateNamed: #northernHemi onDimension: (dims at: #location) parent: world.\n\tcoords := Dictionary new.\n\tcoords at: #screenParent put: (slotSpace addCoordinateNamed: #screenParent onDimension: (dims at: #rcvr) parent: nil).\n\tcoords at: #screen put: (slotSpace addCoordinateNamed: #screen onDimension: (dims at: #rcvr) parent: (coords at: #screenParent)).\n\tcoords at: #southernHemi put: southern.\n\tcoords at: #northernHemi put: northern.\n\tcoords at: #australia put: (slotSpace addCoordinateNamed: #australia onDimension: (dims at: #location) parent: southern).\n\tcoords at: #antarctica put: (slotSpace addCoordinateNamed: #antarctica onDimension: (dims at: #location) parent: southern).\n\tcoords at: #false put: (slotSpace addCoordinateNamed: #false onDimension: (dims at: #isColorblind) parent: nil).\n\tcoords at: #true put: (slotSpace addCoordinateNamed: #true onDimension: (dims at: #isColorblind) parent: nil).\n\tself addDrawPixelSlotsOn: slotSpace dimensions: dims coordinates: coords.\n\t^ Dictionary newFrom: { #slotSpace -> slotSpace. #dimensions -> dims. #coordinates -> coords }' 'private - building'\n\n'addDrawPixelSlotsOn: slotSpace dimensions: dimensions coordinates: coordinates\n\t| rcvr location vision |\n\trcvr := dimensions at: #rcvr.\n\tlocation := dimensions at: #location.\n\tvision := dimensions at: #isColorblind.\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #drawPixel dimensionConstraints: (Dictionary newFrom: { rcvr -> (coordinates at: #screenParent) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | ''baseline renderer'' ]).\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #drawPixel dimensionConstraints: (Dictionary newFrom: { rcvr -> (coordinates at: #screenParent). location -> (coordinates at: #southernHemi) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | ''southern hemisphere override'' ]).\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #drawPixel dimensionConstraints: (Dictionary newFrom: { rcvr -> (coordinates at: #screenParent). vision -> (coordinates at: #true) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | ''colorblind override'' ]).\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #drawPixel dimensionConstraints: (Dictionary newFrom: { rcvr -> (coordinates at: #screenParent). location -> (coordinates at: #southernHemi). vision -> (coordinates at: #true) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | ''southern colorblind override'' ])' 'private - building'\n\n'bracketBoundaryCoordinatesFrom: coordinates\n\t^ Dictionary newFrom: {\n\t\t#square -> (coordinates at: #square).\n\t\t#round -> (coordinates at: #round).\n\t\t#curly -> (coordinates at: #curly).\n\t\t#angle -> (coordinates at: #angle) }' 'private - building'\n\n'bracketSeesScenario\n\t| slotSpace boundaryDimension povDimension coords |\n\tslotSpace := KoSlotSpace new.\n\tboundaryDimension := slotSpace addDimensionNamed: #boundaryType.\n\tpovDimension := slotSpace addDimensionNamed: #pov.\n\tcoords := Dictionary new.\n\tcoords at: #square put: (slotSpace addCoordinateNamed: #square onDimension: boundaryDimension parent: nil).\n\tcoords at: #round put: (slotSpace addCoordinateNamed: #round onDimension: boundaryDimension parent: nil).\n\tcoords at: #curly put: (slotSpace addCoordinateNamed: #curly onDimension: boundaryDimension parent: nil).\n\tcoords at: #angle put: (slotSpace addCoordinateNamed: #angle onDimension: boundaryDimension parent: nil).\n\tcoords at: #povAdjacent put: (slotSpace addCoordinateNamed: #povAdjacent onDimension: povDimension parent: nil).\n\tcoords at: #povSymmetric put: (slotSpace addCoordinateNamed: #povSymmetric onDimension: povDimension parent: nil).\n\tself addBracketSeesSlotsOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension coordinates: coords.\n\t^ Dictionary newFrom: {\n\t\t#slotSpace -> slotSpace.\n\t\t#dimensions -> (Dictionary newFrom: { #boundaryType -> boundaryDimension. #pov -> povDimension }).\n\t\t#coordinates -> coords }' 'private - building'\n\n'addBracketSeesSlotsOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension coordinates: coordinates\n\t| square round curly angle adjacent symmetric |\n\tsquare := coordinates at: #square.\n\tround := coordinates at: #round.\n\tcurly := coordinates at: #curly.\n\tangle := coordinates at: #angle.\n\tadjacent := coordinates at: #povAdjacent.\n\tsymmetric := coordinates at: #povSymmetric.\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: square pov: adjacent result: #(round curly).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: round pov: adjacent result: #(curly square).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: curly pov: adjacent result: #(round angle square).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: angle pov: adjacent result: #(curly).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: square pov: symmetric result: #(round curly).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: round pov: symmetric result: #(curly square).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: curly pov: symmetric result: #(round angle square).\n\tself addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: angle pov: symmetric result: #(curly)' 'private - building'\n\n'addSeesSlotOn: slotSpace boundaryDimension: boundaryDimension povDimension: povDimension boundary: boundary pov: pov result: resultCollection\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #sees dimensionConstraints: (Dictionary newFrom: { boundaryDimension -> boundary. povDimension -> pov }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | resultCollection ])' 'private - building'\n\n'yonedaScenario\n\t| slotSpace povDimension objectDimension coords |\n\tslotSpace := KoSlotSpace new.\n\tpovDimension := slotSpace addDimensionNamed: #pov.\n\tobjectDimension := slotSpace addDimensionNamed: #object.\n\tcoords := Dictionary new.\n\tcoords at: #povLocal put: (slotSpace addCoordinateNamed: #povLocal onDimension: povDimension parent: nil).\n\tcoords at: #povMeta put: (slotSpace addCoordinateNamed: #povMeta onDimension: povDimension parent: nil).\n\tcoords at: #nodeA put: (slotSpace addCoordinateNamed: #nodeA onDimension: objectDimension parent: nil).\n\tcoords at: #nodeB put: (slotSpace addCoordinateNamed: #nodeB onDimension: objectDimension parent: nil).\n\tcoords at: #nodeC put: (slotSpace addCoordinateNamed: #nodeC onDimension: objectDimension parent: nil).\n\tself addYonedaSlotsOn: slotSpace povDimension: povDimension objectDimension: objectDimension coordinates: coords.\n\t^ Dictionary newFrom: {\n\t\t#slotSpace -> slotSpace.\n\t\t#dimensions -> (Dictionary newFrom: { #pov -> povDimension. #object -> objectDimension }).\n\t\t#coordinates -> coords }' 'private - building'\n\n'addYonedaSlotsOn: slotSpace povDimension: povDimension objectDimension: objectDimension coordinates: coordinates\n\t| povLocal povMeta nodeA nodeB nodeC |\n\tpovLocal := coordinates at: #povLocal.\n\tpovMeta := coordinates at: #povMeta.\n\tnodeA := coordinates at: #nodeA.\n\tnodeB := coordinates at: #nodeB.\n\tnodeC := coordinates at: #nodeC.\n\tself addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: povLocal object: nodeA result: #(fromB).\n\tself addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: povLocal object: nodeB result: #(fromC).\n\tself addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: povLocal object: nodeC result: #(fromB).\n\tself addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: povMeta object: nodeA result: #(fromAll).\n\tself addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: povMeta object: nodeB result: #(fromAll).\n\tself addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: povMeta object: nodeC result: #(fromAll)' 'private - building'\n\n'addProfileSlotOn: slotSpace povDimension: povDimension objectDimension: objectDimension pov: pov object: object result: resultCollection\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #profile dimensionConstraints: (Dictionary newFrom: { povDimension -> pov. objectDimension -> object }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | resultCollection ])' 'private - building'\n\n'pileScenario\n\t| slotSpace selectionDimension coords |\n\tslotSpace := KoSlotSpace new.\n\tselectionDimension := slotSpace addDimensionNamed: #selection.\n\tcoords := Dictionary new.\n\tcoords at: #tops put: (slotSpace addCoordinateNamed: #tops onDimension: selectionDimension parent: nil).\n\tcoords at: #all put: (slotSpace addCoordinateNamed: #all onDimension: selectionDimension parent: nil).\n\tself addPileSlotsOn: slotSpace selectionDimension: selectionDimension coordinates: coords.\n\t^ Dictionary newFrom: {\n\t\t#slotSpace -> slotSpace.\n\t\t#dimensions -> (Dictionary newFrom: { #selection -> selectionDimension }).\n\t\t#coordinates -> coords }' 'private - building'\n\n'addPileSlotsOn: slotSpace selectionDimension: selectionDimension coordinates: coordinates\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #project dimensionConstraints: (Dictionary newFrom: { selectionDimension -> (coordinates at: #tops) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | #(topA topB) ]).\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #project dimensionConstraints: (Dictionary newFrom: { selectionDimension -> (coordinates at: #all) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | #(topA midC baseD) ])' 'private - building'\n\n'combinerScenario\n\t| slotSpace combinerDimension coords |\n\tslotSpace := KoSlotSpace new.\n\tcombinerDimension := slotSpace addDimensionNamed: #combiner.\n\tcoords := Dictionary new.\n\tcoords at: #meet put: (slotSpace addCoordinateNamed: #meet onDimension: combinerDimension parent: nil).\n\tcoords at: #quorum put: (slotSpace addCoordinateNamed: #quorum onDimension: combinerDimension parent: nil).\n\tself addCombinerSlotsOn: slotSpace combinerDimension: combinerDimension coordinates: coords.\n\t^ Dictionary newFrom: { #slotSpace -> slotSpace. #dimensions -> (Dictionary newFrom: { #combiner -> combinerDimension }). #coordinates -> coords }' 'private - building'\n\n'addCombinerSlotsOn: slotSpace combinerDimension: combinerDimension coordinates: coordinates\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #stabilize dimensionConstraints: (Dictionary newFrom: { combinerDimension -> (coordinates at: #meet) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | ''intersection of candidates'' ]).\n\tslotSpace addSlot: (KoSlot\n\t\tguard: (KoSlotGuard selector: #stabilize dimensionConstraints: (Dictionary newFrom: { combinerDimension -> (coordinates at: #quorum) }) parameterConstraints: nil)\n\t\tcontents: [ :ctx :args | ''accept proposals supported by >= 2 POVs'' ])' 'private - building'\n) pairsDo: [ :src :prot | (KoSlotSpaceExamples class) compile: src classified: prot ].\n\n\"7) Smoke tests: run a few examples and print a one-line summary\"\nresultSummary := [\n\t{\n\t\t#exampleSlotMatching -> (KoSlotSpaceExamples exampleSlotMatching keys asArray).\n\t\t#exampleBracketSees -> (KoSlotSpaceExamples exampleBracketSees keys asArray).\n\t\t#exampleYonedaProfiles -> (KoSlotSpaceExamples exampleYonedaProfiles keys asArray) } ] on: Error do: [ :ex | ex description ].\n\nTranscript\n\tcr; show: '[Korz] Reoriented. Examples compiled. Probe => '; show: resultSummary printString; cr.\n\n\"Done.\"\n```\n\nIf this still trips anywhere, paste the *first* DNU you see (selector name only), and I’ll trim the shim further.\n"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-11-14T07:48:57.737182+01:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-11-14T07:48:57.737182+01:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : " Probes your image for the Korz API"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "af70a40f-eaff-0d00-91a6-a01a0a2dc40b"
	}
}